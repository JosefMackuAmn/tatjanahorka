/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/*!********************************!*\
  !*** ./src/client/js/index.js ***!
  \********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements:  */
eval("// UTILITY FUNCTIONS\r\n\r\n// Rendering the element or removing it from the screen smoothly - with animations\r\n// The element must have 3 CSS Classes available - hidden class, visible class, hiding class\r\n// Hidden class - display: none, no animation\r\n// Visible class - display: block (or whatever except none) and an animation of the element appearing on the page (sliding -in or so)\r\n// Hiding class - animation of the element disappearing\r\n// Element has only one of these classes at a time.\r\nconst showOrHideEl = (element, cssClass) => {\r\n    if([...element.classList].includes(`${cssClass}--hidden`)) {\r\n        element.classList.remove(`${cssClass}--hidden`);\r\n        element.classList.add(`${cssClass}--visible`);\r\n    } else if ([...element.classList].includes(`${cssClass}--visible`)) {\r\n        element.classList.remove(`${cssClass}--visible`);\r\n        element.classList.add(`${cssClass}--hiding`);\r\n    } else {\r\n        element.classList.remove(`${cssClass}--hiding`);\r\n        element.classList.add(`${cssClass}--hidden`);\r\n    }\r\n}\r\n\r\n// ORGANIZATIONS\r\n\r\nconst organizationContainer = document.querySelector('.organizations__container');\r\nconst organizationElements = [...organizationContainer.children];\r\n\r\n//When mouse cursor enters organization div, rendering animation\r\norganizationElements.forEach((organization, id) => {\r\n    organization.addEventListener('mouseenter', () => {\r\n       createWaveAnimation(id);\r\n    })\r\n})  \r\n   \r\n// Creating hidden style element for @keyframes \r\nconst animations = document.createElement('style');\r\ndocument.documentElement.appendChild(animations);\r\n\r\n// The wave svg isn´t by default pointing to 0 rad, so I experimentally found out the angle correction\r\nconst angleCorrection = -1; //[rad]\r\n\r\n// Counting each wave animation creating. This count is used for creating unique animation id´s\r\nlet animationCounter = 0;\r\n\r\n// Managing all currently needed @keyframes in an array\r\nlet keyframesList = [];\r\n\r\n// Setting max amount and min amount of waves that can appear\r\nconst maxWaves = 5;\r\nconst minWaves = 2;\r\n\r\n//Setting initial wave range\r\nlet waveRange = 10; //[rem]\r\n\r\n// This function sets the wave range taking the window size in account \r\nconst setUpWaveRange = () => {\r\n    if(document.documentElement.clientWidth < 1100 && document.documentElement.clientWidth >= 800) {\r\n        waveRange = 7;\r\n    } else if (document.documentElement.clientWidth < 800) {\r\n        waveRange = 6;\r\n    } else {\r\n        waveRange = 10;\r\n    }\r\n}\r\n\r\n// Whenever window is resized, configuring the wave range, so the wave range is \"responsive\"\r\nwindow.addEventListener('resize', () => {\r\n    setUpWaveRange();\r\n})\r\n\r\n// Function animates wave element in specified organization element\r\nconst animateWave = (wave, organizationIndex) => {\r\n\r\n    //Generating random angle to get direction, in which the wave will move\r\n    const randomAngle = Math.random()*2*Math.PI;\r\n\r\n    //Generating X and Y offset from the original position based on the random angle\r\n    const moveX = Math.cos(randomAngle)*waveRange;\r\n    const moveY = Math.sin(randomAngle)*waveRange;\r\n\r\n    //Animation id refers to the total amount of animations created, therefore is unique\r\n    const animationId = animationCounter;\r\n\r\n    //Generating @keyframes identifier - animation name\r\n    const animationName = `waveAnimation--${organizationIndex}--${animationId}`\r\n    animationCounter++;\r\n\r\n    //Generating keyframes\r\n    const keyframes = `@keyframes ${animationName} {\r\n        0% {\r\n            transform: scale(0.1) translateX(0) translateY(0) rotate(${randomAngle + angleCorrection}rad);\r\n            opacity: 0;\r\n            filter: blur(0px);\r\n        }\r\n        50% {\r\n            opacity: .3;\r\n        }\r\n        100% {\r\n            transform: scale(2) translateX(${moveX}rem) translateY(${moveY}rem) rotate(${randomAngle + angleCorrection}rad);\r\n            opacity : 0;\r\n            filter: blur(2px);\r\n            \r\n        }\r\n    }`\r\n\r\n    // Adding keyframes to keyframeslist. (Manages all active animations)\r\n    keyframesList.push({id: animationId, keyframes: keyframes});\r\n\r\n    // Replacing the <style> element´s content with a new text content, that contains all the keyframes from animationList\r\n    animations.textContent = keyframesList.map(item => item.keyframes).join(' ');\r\n\r\n    // Applying animation to the wave element\r\n    wave.style.animation = `${animationName} 3s forwards`;\r\n\r\n    // Handling situation, hen wave element animation finishes\r\n    wave.addEventListener('animationend', () => {\r\n\r\n        // Removing animation keyframes from the keyframesList\r\n        keyframesList.splice(keyframesList.findIndex((item) => {\r\n            return animationId === item.id;\r\n        }), 1);\r\n\r\n        //Updatng <style> element\r\n        animations.textContent = keyframesList.map(item => item.keyframes).join(' ');\r\n\r\n        // Remowing wave element from DOM\r\n        wave.parentElement.removeChild(wave);\r\n    });\r\n}\r\n\r\n//Creates a new wave element\r\nconst spawnWave = (id) => {\r\n    const wave = document.createElement('div');\r\n    wave.classList = `organizations__wave organizationions__wave--${id}`;\r\n\r\n    return wave;\r\n}\r\n\r\n//Generates wave animation for specified organization\r\nconst createWaveAnimation = (organizationIndex) => {\r\n\r\n    //Hooking organization element\r\n    const organization = organizationElements[organizationIndex];\r\n\r\n    //Selecting number of animations, that will appear during the animation (number is whole and falls between maxWaves and minWaves)\r\n    const waveNum = Math.floor(Math.random()*(maxWaves-minWaves) + minWaves);\r\n\r\n    //Creating selected number of waves, animating them\r\n    for(let i = 0; i < waveNum; i++) {\r\n        const wave = spawnWave(i);\r\n        organization.appendChild(wave);\r\n        animateWave(wave, organizationIndex);\r\n    }\r\n}\r\n\r\n//Setting up wave range initially\r\nsetUpWaveRange();\r\n\r\n//REVIEWS\r\n\r\n//Cyclically changes the state of review elements (HIDDEN -> VISIBLE -> HIDING -> HIDDEN -> ...)\r\nconst showOrHideReviewElements = (reviewLeaf, reviewPerson, reviewText) => {\r\n    showOrHideEl(reviewLeaf, 'review__leaf');\r\n    showOrHideEl(reviewPerson, 'review__person');\r\n    showOrHideEl(reviewText, 'review__text');\r\n}\r\n\r\n//Hooking reviews section\r\nconst reviewsSection = document.getElementById('reviews');\r\n\r\n//Getting array of reviews\r\nconst reviews = reviewsSection.children;\r\n\r\n//Setting up iterator\r\nlet currentId = 0;\r\n\r\n//When called, starts cycling through reviews (browser calls it again, when leaf animation ends) \r\nconst reviewCycler = () => {\r\n        //Getting current review\r\n        const review = reviews[currentId];\r\n\r\n        //Adding active class, so the reviw doesn´t have display: none anymore\r\n        review.classList.add('review--active');\r\n\r\n        //Getting reviewLeaf, reviewText and reviewPerson\r\n        const reviewLeaf = review.querySelector('.review__leaf');\r\n        const reviewText = review.querySelector('.review__text');\r\n        const reviewPerson = review.querySelector('.review__person');\r\n    \r\n        //Setting state for review elements from HIDDEN to VISIBLE\r\n        showOrHideReviewElements(reviewLeaf, reviewPerson, reviewText);\r\n      \r\n        //Incrementing the iterator\r\n        currentId++;\r\n\r\n        //If the iterator after incrementing exceeds review count, setting it back to 0, so the cycling can continue from the first review\r\n        if(currentId === reviews.length) {\r\n            currentId = 0;\r\n        }\r\n\r\n        //Setting timeout for when should the review start disappearing\r\n        setTimeout(() => {\r\n\r\n            //Setting state for review elements from VISIBLE to HIDING\r\n            showOrHideReviewElements(reviewLeaf, reviewPerson, reviewText);\r\n\r\n            //When leaf fall animation finishes\r\n            reviewLeaf.addEventListener('animationend', () => {\r\n\r\n                 //Setting state for review elements from HIDING to HIDDEN\r\n                showOrHideReviewElements(reviewLeaf, reviewPerson, reviewText);\r\n\r\n                //Removing the review active class, therefore display: none is set\r\n                review.classList.remove('review--active');\r\n\r\n                //Beginning antother cycle\r\n                reviewCycler();\r\n\r\n            }, \r\n            // Making sure, that the leaf fall animation event triggers only once\r\n            {\r\n                capture: false,\r\n                once: true,\r\n                passive: false\r\n                });\r\n        }, 7000);\r\n       \r\n\r\n}\r\n\r\n//Starting to cycle when the page loads\r\nreviewCycler();\r\n\r\n\r\n//////////////////\r\n///// POST EMAIL FORM\r\n//////////////////\r\nconst emailInput = document.getElementById('email');\r\nemailInput.addEventListener('input', () => {\r\n    const submit = document.getElementById('submit');\r\n    submit.classList.remove('hidden');\r\n    setTimeout(() => {\r\n        submit.style.opacity = \"1\";\r\n    }, 20);\r\n});\r\n\r\n//////////////////\r\n///// POST-SCRIPTUM EXPANSION\r\n//////////////////\r\nconst postScriptum = document.getElementById('post-scriptum');\r\nconst showPSPhoto = () => {\r\n    postScriptum.classList.remove('closed');\r\n    postScriptum.removeEventListener('click', showPSPhoto);\r\n}\r\npostScriptum.addEventListener('click', showPSPhoto);\r\n\r\n//////////////////\r\n///// SUCCESS MODAL\r\n//////////////////\r\nconst search = window.location.search;\r\nif (search) {\r\n    const params = search.split('=');\r\n    if (params && params[0] === '?success' || params[0] === 'success') {\r\n        const success = params[1];\r\n\r\n        const showHideModal = (className, text) => {\r\n            const modalEl = document.createElement('div');        \r\n            const header = document.getElementById('header');\r\n            modalEl.classList.add('modal');\r\n            modalEl.classList.add(className);\r\n            modalEl.textContent = text;\r\n            header.append(modalEl);\r\n\r\n            setTimeout(() => {\r\n                modalEl.remove();\r\n            }, 5000);\r\n        }\r\n\r\n        switch (success) {\r\n            case 'true': {\r\n                showHideModal('success', 'Povedlo se přidat Váš e-mail!');\r\n                break;\r\n            }\r\n            case 'false': {\r\n                showHideModal('fail', 'Přidání e-mailu se nepodařilo.');\r\n                break;\r\n            }\r\n            default: null;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//////////////////\r\n///// ANIMATIONS\r\n//////////////////\r\n\r\n//Collecting all elements with class \"toBeAnimated\"\r\nconst toBeAnimatedElements = document.querySelectorAll('.toBeAnimated');\r\n\r\n//Creating array of pairs of to be animated elements and their distance from document top border  -> [[element1, distance1], [element2, distance2], ... ]\r\nlet toBeAnimated = [];\r\nfor (const element of toBeAnimatedElements) {\r\n    toBeAnimated.push([element, element.getBoundingClientRect().y + document.documentElement.scrollTop]);\r\n}\r\n\r\nconst toBeAnimatedSnapshot = toBeAnimated;\r\n\r\n//Handler for 'scroll' event on document.window, triggers animations\r\nconst animationTriggerer = () => {\r\n\r\n    //Contains id´s of elements (in toBeAnimated[]), that are going to be animated this function call\r\n    const willBeAnimated = [];\r\n\r\n    for (const animation of toBeAnimated) {\r\n\r\n        if (animation === undefined) {\r\n            continue;\r\n        }\r\n\r\n        //If the distance between window top and element´s y coordinate is small enough, animating the element\r\n        if (animation[1] - document.documentElement.scrollTop <= window.innerHeight - 100) {\r\n\r\n            //Removing toBeAnimated class\r\n            animation[0].classList.remove('toBeAnimated');\r\n\r\n            //Finding index of the element\r\n            const id = toBeAnimated.findIndex((anim) => {\r\n                return animation === anim;\r\n            })\r\n\r\n            //Adding index to the list\r\n            willBeAnimated.push(id);\r\n        }  \r\n    }\r\n\r\n    //If there are some elements that are going to be animated this function call\r\n    if (willBeAnimated.length > 0) {\r\n\r\n        //Mapping toBeAnimated array to an array, in which the elements animated this function call are not included\r\n        toBeAnimated = toBeAnimated.map((value, idx) => {\r\n            for (const id of willBeAnimated) {\r\n                if (id === idx) {\r\n                    return;\r\n                }\r\n            }\r\n            return value;\r\n        })\r\n    }\r\n}\r\n\r\n//When user scrolls, triggering animations\r\nwindow.addEventListener('scroll', () => {\r\n    animationTriggerer();\r\n})\r\n\r\n//Preventing misbehavior on window resize\r\nwindow.addEventListener('resize', () => {\r\n    toBeAnimated = toBeAnimatedSnapshot;\r\n})\r\n\r\n//Triggering animations on page load\r\nanimationTriggerer();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2xpZW50L2pzL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGF0amFuYWhvcmthLy4vc3JjL2NsaWVudC9qcy9pbmRleC5qcz8yYTUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFVUSUxJVFkgRlVOQ1RJT05TXHJcblxyXG4vLyBSZW5kZXJpbmcgdGhlIGVsZW1lbnQgb3IgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgc2NyZWVuIHNtb290aGx5IC0gd2l0aCBhbmltYXRpb25zXHJcbi8vIFRoZSBlbGVtZW50IG11c3QgaGF2ZSAzIENTUyBDbGFzc2VzIGF2YWlsYWJsZSAtIGhpZGRlbiBjbGFzcywgdmlzaWJsZSBjbGFzcywgaGlkaW5nIGNsYXNzXHJcbi8vIEhpZGRlbiBjbGFzcyAtIGRpc3BsYXk6IG5vbmUsIG5vIGFuaW1hdGlvblxyXG4vLyBWaXNpYmxlIGNsYXNzIC0gZGlzcGxheTogYmxvY2sgKG9yIHdoYXRldmVyIGV4Y2VwdCBub25lKSBhbmQgYW4gYW5pbWF0aW9uIG9mIHRoZSBlbGVtZW50IGFwcGVhcmluZyBvbiB0aGUgcGFnZSAoc2xpZGluZyAtaW4gb3Igc28pXHJcbi8vIEhpZGluZyBjbGFzcyAtIGFuaW1hdGlvbiBvZiB0aGUgZWxlbWVudCBkaXNhcHBlYXJpbmdcclxuLy8gRWxlbWVudCBoYXMgb25seSBvbmUgb2YgdGhlc2UgY2xhc3NlcyBhdCBhIHRpbWUuXHJcbmNvbnN0IHNob3dPckhpZGVFbCA9IChlbGVtZW50LCBjc3NDbGFzcykgPT4ge1xyXG4gICAgaWYoWy4uLmVsZW1lbnQuY2xhc3NMaXN0XS5pbmNsdWRlcyhgJHtjc3NDbGFzc30tLWhpZGRlbmApKSB7XHJcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGAke2Nzc0NsYXNzfS0taGlkZGVuYCk7XHJcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGAke2Nzc0NsYXNzfS0tdmlzaWJsZWApO1xyXG4gICAgfSBlbHNlIGlmIChbLi4uZWxlbWVudC5jbGFzc0xpc3RdLmluY2x1ZGVzKGAke2Nzc0NsYXNzfS0tdmlzaWJsZWApKSB7XHJcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGAke2Nzc0NsYXNzfS0tdmlzaWJsZWApO1xyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChgJHtjc3NDbGFzc30tLWhpZGluZ2ApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoYCR7Y3NzQ2xhc3N9LS1oaWRpbmdgKTtcclxuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoYCR7Y3NzQ2xhc3N9LS1oaWRkZW5gKTtcclxuICAgIH1cclxufVxyXG5cclxuLy8gT1JHQU5JWkFUSU9OU1xyXG5cclxuY29uc3Qgb3JnYW5pemF0aW9uQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm9yZ2FuaXphdGlvbnNfX2NvbnRhaW5lcicpO1xyXG5jb25zdCBvcmdhbml6YXRpb25FbGVtZW50cyA9IFsuLi5vcmdhbml6YXRpb25Db250YWluZXIuY2hpbGRyZW5dO1xyXG5cclxuLy9XaGVuIG1vdXNlIGN1cnNvciBlbnRlcnMgb3JnYW5pemF0aW9uIGRpdiwgcmVuZGVyaW5nIGFuaW1hdGlvblxyXG5vcmdhbml6YXRpb25FbGVtZW50cy5mb3JFYWNoKChvcmdhbml6YXRpb24sIGlkKSA9PiB7XHJcbiAgICBvcmdhbml6YXRpb24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsICgpID0+IHtcclxuICAgICAgIGNyZWF0ZVdhdmVBbmltYXRpb24oaWQpO1xyXG4gICAgfSlcclxufSkgIFxyXG4gICBcclxuLy8gQ3JlYXRpbmcgaGlkZGVuIHN0eWxlIGVsZW1lbnQgZm9yIEBrZXlmcmFtZXMgXHJcbmNvbnN0IGFuaW1hdGlvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoYW5pbWF0aW9ucyk7XHJcblxyXG4vLyBUaGUgd2F2ZSBzdmcgaXNuwrR0IGJ5IGRlZmF1bHQgcG9pbnRpbmcgdG8gMCByYWQsIHNvIEkgZXhwZXJpbWVudGFsbHkgZm91bmQgb3V0IHRoZSBhbmdsZSBjb3JyZWN0aW9uXHJcbmNvbnN0IGFuZ2xlQ29ycmVjdGlvbiA9IC0xOyAvL1tyYWRdXHJcblxyXG4vLyBDb3VudGluZyBlYWNoIHdhdmUgYW5pbWF0aW9uIGNyZWF0aW5nLiBUaGlzIGNvdW50IGlzIHVzZWQgZm9yIGNyZWF0aW5nIHVuaXF1ZSBhbmltYXRpb24gaWTCtHNcclxubGV0IGFuaW1hdGlvbkNvdW50ZXIgPSAwO1xyXG5cclxuLy8gTWFuYWdpbmcgYWxsIGN1cnJlbnRseSBuZWVkZWQgQGtleWZyYW1lcyBpbiBhbiBhcnJheVxyXG5sZXQga2V5ZnJhbWVzTGlzdCA9IFtdO1xyXG5cclxuLy8gU2V0dGluZyBtYXggYW1vdW50IGFuZCBtaW4gYW1vdW50IG9mIHdhdmVzIHRoYXQgY2FuIGFwcGVhclxyXG5jb25zdCBtYXhXYXZlcyA9IDU7XHJcbmNvbnN0IG1pbldhdmVzID0gMjtcclxuXHJcbi8vU2V0dGluZyBpbml0aWFsIHdhdmUgcmFuZ2VcclxubGV0IHdhdmVSYW5nZSA9IDEwOyAvL1tyZW1dXHJcblxyXG4vLyBUaGlzIGZ1bmN0aW9uIHNldHMgdGhlIHdhdmUgcmFuZ2UgdGFraW5nIHRoZSB3aW5kb3cgc2l6ZSBpbiBhY2NvdW50IFxyXG5jb25zdCBzZXRVcFdhdmVSYW5nZSA9ICgpID0+IHtcclxuICAgIGlmKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCA8IDExMDAgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoID49IDgwMCkge1xyXG4gICAgICAgIHdhdmVSYW5nZSA9IDc7XHJcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCA8IDgwMCkge1xyXG4gICAgICAgIHdhdmVSYW5nZSA9IDY7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdhdmVSYW5nZSA9IDEwO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBXaGVuZXZlciB3aW5kb3cgaXMgcmVzaXplZCwgY29uZmlndXJpbmcgdGhlIHdhdmUgcmFuZ2UsIHNvIHRoZSB3YXZlIHJhbmdlIGlzIFwicmVzcG9uc2l2ZVwiXHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB7XHJcbiAgICBzZXRVcFdhdmVSYW5nZSgpO1xyXG59KVxyXG5cclxuLy8gRnVuY3Rpb24gYW5pbWF0ZXMgd2F2ZSBlbGVtZW50IGluIHNwZWNpZmllZCBvcmdhbml6YXRpb24gZWxlbWVudFxyXG5jb25zdCBhbmltYXRlV2F2ZSA9ICh3YXZlLCBvcmdhbml6YXRpb25JbmRleCkgPT4ge1xyXG5cclxuICAgIC8vR2VuZXJhdGluZyByYW5kb20gYW5nbGUgdG8gZ2V0IGRpcmVjdGlvbiwgaW4gd2hpY2ggdGhlIHdhdmUgd2lsbCBtb3ZlXHJcbiAgICBjb25zdCByYW5kb21BbmdsZSA9IE1hdGgucmFuZG9tKCkqMipNYXRoLlBJO1xyXG5cclxuICAgIC8vR2VuZXJhdGluZyBYIGFuZCBZIG9mZnNldCBmcm9tIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgcmFuZG9tIGFuZ2xlXHJcbiAgICBjb25zdCBtb3ZlWCA9IE1hdGguY29zKHJhbmRvbUFuZ2xlKSp3YXZlUmFuZ2U7XHJcbiAgICBjb25zdCBtb3ZlWSA9IE1hdGguc2luKHJhbmRvbUFuZ2xlKSp3YXZlUmFuZ2U7XHJcblxyXG4gICAgLy9BbmltYXRpb24gaWQgcmVmZXJzIHRvIHRoZSB0b3RhbCBhbW91bnQgb2YgYW5pbWF0aW9ucyBjcmVhdGVkLCB0aGVyZWZvcmUgaXMgdW5pcXVlXHJcbiAgICBjb25zdCBhbmltYXRpb25JZCA9IGFuaW1hdGlvbkNvdW50ZXI7XHJcblxyXG4gICAgLy9HZW5lcmF0aW5nIEBrZXlmcmFtZXMgaWRlbnRpZmllciAtIGFuaW1hdGlvbiBuYW1lXHJcbiAgICBjb25zdCBhbmltYXRpb25OYW1lID0gYHdhdmVBbmltYXRpb24tLSR7b3JnYW5pemF0aW9uSW5kZXh9LS0ke2FuaW1hdGlvbklkfWBcclxuICAgIGFuaW1hdGlvbkNvdW50ZXIrKztcclxuXHJcbiAgICAvL0dlbmVyYXRpbmcga2V5ZnJhbWVzXHJcbiAgICBjb25zdCBrZXlmcmFtZXMgPSBgQGtleWZyYW1lcyAke2FuaW1hdGlvbk5hbWV9IHtcclxuICAgICAgICAwJSB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC4xKSB0cmFuc2xhdGVYKDApIHRyYW5zbGF0ZVkoMCkgcm90YXRlKCR7cmFuZG9tQW5nbGUgKyBhbmdsZUNvcnJlY3Rpb259cmFkKTtcclxuICAgICAgICAgICAgb3BhY2l0eTogMDtcclxuICAgICAgICAgICAgZmlsdGVyOiBibHVyKDBweCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDUwJSB7XHJcbiAgICAgICAgICAgIG9wYWNpdHk6IC4zO1xyXG4gICAgICAgIH1cclxuICAgICAgICAxMDAlIHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgyKSB0cmFuc2xhdGVYKCR7bW92ZVh9cmVtKSB0cmFuc2xhdGVZKCR7bW92ZVl9cmVtKSByb3RhdGUoJHtyYW5kb21BbmdsZSArIGFuZ2xlQ29ycmVjdGlvbn1yYWQpO1xyXG4gICAgICAgICAgICBvcGFjaXR5IDogMDtcclxuICAgICAgICAgICAgZmlsdGVyOiBibHVyKDJweCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgIH1gXHJcblxyXG4gICAgLy8gQWRkaW5nIGtleWZyYW1lcyB0byBrZXlmcmFtZXNsaXN0LiAoTWFuYWdlcyBhbGwgYWN0aXZlIGFuaW1hdGlvbnMpXHJcbiAgICBrZXlmcmFtZXNMaXN0LnB1c2goe2lkOiBhbmltYXRpb25JZCwga2V5ZnJhbWVzOiBrZXlmcmFtZXN9KTtcclxuXHJcbiAgICAvLyBSZXBsYWNpbmcgdGhlIDxzdHlsZT4gZWxlbWVudMK0cyBjb250ZW50IHdpdGggYSBuZXcgdGV4dCBjb250ZW50LCB0aGF0IGNvbnRhaW5zIGFsbCB0aGUga2V5ZnJhbWVzIGZyb20gYW5pbWF0aW9uTGlzdFxyXG4gICAgYW5pbWF0aW9ucy50ZXh0Q29udGVudCA9IGtleWZyYW1lc0xpc3QubWFwKGl0ZW0gPT4gaXRlbS5rZXlmcmFtZXMpLmpvaW4oJyAnKTtcclxuXHJcbiAgICAvLyBBcHBseWluZyBhbmltYXRpb24gdG8gdGhlIHdhdmUgZWxlbWVudFxyXG4gICAgd2F2ZS5zdHlsZS5hbmltYXRpb24gPSBgJHthbmltYXRpb25OYW1lfSAzcyBmb3J3YXJkc2A7XHJcblxyXG4gICAgLy8gSGFuZGxpbmcgc2l0dWF0aW9uLCBoZW4gd2F2ZSBlbGVtZW50IGFuaW1hdGlvbiBmaW5pc2hlc1xyXG4gICAgd2F2ZS5hZGRFdmVudExpc3RlbmVyKCdhbmltYXRpb25lbmQnLCAoKSA9PiB7XHJcblxyXG4gICAgICAgIC8vIFJlbW92aW5nIGFuaW1hdGlvbiBrZXlmcmFtZXMgZnJvbSB0aGUga2V5ZnJhbWVzTGlzdFxyXG4gICAgICAgIGtleWZyYW1lc0xpc3Quc3BsaWNlKGtleWZyYW1lc0xpc3QuZmluZEluZGV4KChpdGVtKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25JZCA9PT0gaXRlbS5pZDtcclxuICAgICAgICB9KSwgMSk7XHJcblxyXG4gICAgICAgIC8vVXBkYXRuZyA8c3R5bGU+IGVsZW1lbnRcclxuICAgICAgICBhbmltYXRpb25zLnRleHRDb250ZW50ID0ga2V5ZnJhbWVzTGlzdC5tYXAoaXRlbSA9PiBpdGVtLmtleWZyYW1lcykuam9pbignICcpO1xyXG5cclxuICAgICAgICAvLyBSZW1vd2luZyB3YXZlIGVsZW1lbnQgZnJvbSBET01cclxuICAgICAgICB3YXZlLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQod2F2ZSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLy9DcmVhdGVzIGEgbmV3IHdhdmUgZWxlbWVudFxyXG5jb25zdCBzcGF3bldhdmUgPSAoaWQpID0+IHtcclxuICAgIGNvbnN0IHdhdmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIHdhdmUuY2xhc3NMaXN0ID0gYG9yZ2FuaXphdGlvbnNfX3dhdmUgb3JnYW5pemF0aW9uaW9uc19fd2F2ZS0tJHtpZH1gO1xyXG5cclxuICAgIHJldHVybiB3YXZlO1xyXG59XHJcblxyXG4vL0dlbmVyYXRlcyB3YXZlIGFuaW1hdGlvbiBmb3Igc3BlY2lmaWVkIG9yZ2FuaXphdGlvblxyXG5jb25zdCBjcmVhdGVXYXZlQW5pbWF0aW9uID0gKG9yZ2FuaXphdGlvbkluZGV4KSA9PiB7XHJcblxyXG4gICAgLy9Ib29raW5nIG9yZ2FuaXphdGlvbiBlbGVtZW50XHJcbiAgICBjb25zdCBvcmdhbml6YXRpb24gPSBvcmdhbml6YXRpb25FbGVtZW50c1tvcmdhbml6YXRpb25JbmRleF07XHJcblxyXG4gICAgLy9TZWxlY3RpbmcgbnVtYmVyIG9mIGFuaW1hdGlvbnMsIHRoYXQgd2lsbCBhcHBlYXIgZHVyaW5nIHRoZSBhbmltYXRpb24gKG51bWJlciBpcyB3aG9sZSBhbmQgZmFsbHMgYmV0d2VlbiBtYXhXYXZlcyBhbmQgbWluV2F2ZXMpXHJcbiAgICBjb25zdCB3YXZlTnVtID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKihtYXhXYXZlcy1taW5XYXZlcykgKyBtaW5XYXZlcyk7XHJcblxyXG4gICAgLy9DcmVhdGluZyBzZWxlY3RlZCBudW1iZXIgb2Ygd2F2ZXMsIGFuaW1hdGluZyB0aGVtXHJcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgd2F2ZU51bTsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgd2F2ZSA9IHNwYXduV2F2ZShpKTtcclxuICAgICAgICBvcmdhbml6YXRpb24uYXBwZW5kQ2hpbGQod2F2ZSk7XHJcbiAgICAgICAgYW5pbWF0ZVdhdmUod2F2ZSwgb3JnYW5pemF0aW9uSW5kZXgpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vL1NldHRpbmcgdXAgd2F2ZSByYW5nZSBpbml0aWFsbHlcclxuc2V0VXBXYXZlUmFuZ2UoKTtcclxuXHJcbi8vUkVWSUVXU1xyXG5cclxuLy9DeWNsaWNhbGx5IGNoYW5nZXMgdGhlIHN0YXRlIG9mIHJldmlldyBlbGVtZW50cyAoSElEREVOIC0+IFZJU0lCTEUgLT4gSElESU5HIC0+IEhJRERFTiAtPiAuLi4pXHJcbmNvbnN0IHNob3dPckhpZGVSZXZpZXdFbGVtZW50cyA9IChyZXZpZXdMZWFmLCByZXZpZXdQZXJzb24sIHJldmlld1RleHQpID0+IHtcclxuICAgIHNob3dPckhpZGVFbChyZXZpZXdMZWFmLCAncmV2aWV3X19sZWFmJyk7XHJcbiAgICBzaG93T3JIaWRlRWwocmV2aWV3UGVyc29uLCAncmV2aWV3X19wZXJzb24nKTtcclxuICAgIHNob3dPckhpZGVFbChyZXZpZXdUZXh0LCAncmV2aWV3X190ZXh0Jyk7XHJcbn1cclxuXHJcbi8vSG9va2luZyByZXZpZXdzIHNlY3Rpb25cclxuY29uc3QgcmV2aWV3c1NlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmV2aWV3cycpO1xyXG5cclxuLy9HZXR0aW5nIGFycmF5IG9mIHJldmlld3NcclxuY29uc3QgcmV2aWV3cyA9IHJldmlld3NTZWN0aW9uLmNoaWxkcmVuO1xyXG5cclxuLy9TZXR0aW5nIHVwIGl0ZXJhdG9yXHJcbmxldCBjdXJyZW50SWQgPSAwO1xyXG5cclxuLy9XaGVuIGNhbGxlZCwgc3RhcnRzIGN5Y2xpbmcgdGhyb3VnaCByZXZpZXdzIChicm93c2VyIGNhbGxzIGl0IGFnYWluLCB3aGVuIGxlYWYgYW5pbWF0aW9uIGVuZHMpIFxyXG5jb25zdCByZXZpZXdDeWNsZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgLy9HZXR0aW5nIGN1cnJlbnQgcmV2aWV3XHJcbiAgICAgICAgY29uc3QgcmV2aWV3ID0gcmV2aWV3c1tjdXJyZW50SWRdO1xyXG5cclxuICAgICAgICAvL0FkZGluZyBhY3RpdmUgY2xhc3MsIHNvIHRoZSByZXZpdyBkb2VzbsK0dCBoYXZlIGRpc3BsYXk6IG5vbmUgYW55bW9yZVxyXG4gICAgICAgIHJldmlldy5jbGFzc0xpc3QuYWRkKCdyZXZpZXctLWFjdGl2ZScpO1xyXG5cclxuICAgICAgICAvL0dldHRpbmcgcmV2aWV3TGVhZiwgcmV2aWV3VGV4dCBhbmQgcmV2aWV3UGVyc29uXHJcbiAgICAgICAgY29uc3QgcmV2aWV3TGVhZiA9IHJldmlldy5xdWVyeVNlbGVjdG9yKCcucmV2aWV3X19sZWFmJyk7XHJcbiAgICAgICAgY29uc3QgcmV2aWV3VGV4dCA9IHJldmlldy5xdWVyeVNlbGVjdG9yKCcucmV2aWV3X190ZXh0Jyk7XHJcbiAgICAgICAgY29uc3QgcmV2aWV3UGVyc29uID0gcmV2aWV3LnF1ZXJ5U2VsZWN0b3IoJy5yZXZpZXdfX3BlcnNvbicpO1xyXG4gICAgXHJcbiAgICAgICAgLy9TZXR0aW5nIHN0YXRlIGZvciByZXZpZXcgZWxlbWVudHMgZnJvbSBISURERU4gdG8gVklTSUJMRVxyXG4gICAgICAgIHNob3dPckhpZGVSZXZpZXdFbGVtZW50cyhyZXZpZXdMZWFmLCByZXZpZXdQZXJzb24sIHJldmlld1RleHQpO1xyXG4gICAgICBcclxuICAgICAgICAvL0luY3JlbWVudGluZyB0aGUgaXRlcmF0b3JcclxuICAgICAgICBjdXJyZW50SWQrKztcclxuXHJcbiAgICAgICAgLy9JZiB0aGUgaXRlcmF0b3IgYWZ0ZXIgaW5jcmVtZW50aW5nIGV4Y2VlZHMgcmV2aWV3IGNvdW50LCBzZXR0aW5nIGl0IGJhY2sgdG8gMCwgc28gdGhlIGN5Y2xpbmcgY2FuIGNvbnRpbnVlIGZyb20gdGhlIGZpcnN0IHJldmlld1xyXG4gICAgICAgIGlmKGN1cnJlbnRJZCA9PT0gcmV2aWV3cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY3VycmVudElkID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vU2V0dGluZyB0aW1lb3V0IGZvciB3aGVuIHNob3VsZCB0aGUgcmV2aWV3IHN0YXJ0IGRpc2FwcGVhcmluZ1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgLy9TZXR0aW5nIHN0YXRlIGZvciByZXZpZXcgZWxlbWVudHMgZnJvbSBWSVNJQkxFIHRvIEhJRElOR1xyXG4gICAgICAgICAgICBzaG93T3JIaWRlUmV2aWV3RWxlbWVudHMocmV2aWV3TGVhZiwgcmV2aWV3UGVyc29uLCByZXZpZXdUZXh0KTtcclxuXHJcbiAgICAgICAgICAgIC8vV2hlbiBsZWFmIGZhbGwgYW5pbWF0aW9uIGZpbmlzaGVzXHJcbiAgICAgICAgICAgIHJldmlld0xlYWYuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgKCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgICAvL1NldHRpbmcgc3RhdGUgZm9yIHJldmlldyBlbGVtZW50cyBmcm9tIEhJRElORyB0byBISURERU5cclxuICAgICAgICAgICAgICAgIHNob3dPckhpZGVSZXZpZXdFbGVtZW50cyhyZXZpZXdMZWFmLCByZXZpZXdQZXJzb24sIHJldmlld1RleHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vUmVtb3ZpbmcgdGhlIHJldmlldyBhY3RpdmUgY2xhc3MsIHRoZXJlZm9yZSBkaXNwbGF5OiBub25lIGlzIHNldFxyXG4gICAgICAgICAgICAgICAgcmV2aWV3LmNsYXNzTGlzdC5yZW1vdmUoJ3Jldmlldy0tYWN0aXZlJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9CZWdpbm5pbmcgYW50b3RoZXIgY3ljbGVcclxuICAgICAgICAgICAgICAgIHJldmlld0N5Y2xlcigpO1xyXG5cclxuICAgICAgICAgICAgfSwgXHJcbiAgICAgICAgICAgIC8vIE1ha2luZyBzdXJlLCB0aGF0IHRoZSBsZWFmIGZhbGwgYW5pbWF0aW9uIGV2ZW50IHRyaWdnZXJzIG9ubHkgb25jZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXB0dXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG9uY2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgNzAwMCk7XHJcbiAgICAgICBcclxuXHJcbn1cclxuXHJcbi8vU3RhcnRpbmcgdG8gY3ljbGUgd2hlbiB0aGUgcGFnZSBsb2Fkc1xyXG5yZXZpZXdDeWNsZXIoKTtcclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8vLy8gUE9TVCBFTUFJTCBGT1JNXHJcbi8vLy8vLy8vLy8vLy8vLy8vL1xyXG5jb25zdCBlbWFpbElucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VtYWlsJyk7XHJcbmVtYWlsSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XHJcbiAgICBjb25zdCBzdWJtaXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3VibWl0Jyk7XHJcbiAgICBzdWJtaXQuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBzdWJtaXQuc3R5bGUub3BhY2l0eSA9IFwiMVwiO1xyXG4gICAgfSwgMjApO1xyXG59KTtcclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLy8vLyBQT1NULVNDUklQVFVNIEVYUEFOU0lPTlxyXG4vLy8vLy8vLy8vLy8vLy8vLy9cclxuY29uc3QgcG9zdFNjcmlwdHVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bvc3Qtc2NyaXB0dW0nKTtcclxuY29uc3Qgc2hvd1BTUGhvdG8gPSAoKSA9PiB7XHJcbiAgICBwb3N0U2NyaXB0dW0uY2xhc3NMaXN0LnJlbW92ZSgnY2xvc2VkJyk7XHJcbiAgICBwb3N0U2NyaXB0dW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzaG93UFNQaG90byk7XHJcbn1cclxucG9zdFNjcmlwdHVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2hvd1BTUGhvdG8pO1xyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vLy8vIFNVQ0NFU1MgTU9EQUxcclxuLy8vLy8vLy8vLy8vLy8vLy8vXHJcbmNvbnN0IHNlYXJjaCA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XHJcbmlmIChzZWFyY2gpIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IHNlYXJjaC5zcGxpdCgnPScpO1xyXG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXNbMF0gPT09ICc/c3VjY2VzcycgfHwgcGFyYW1zWzBdID09PSAnc3VjY2VzcycpIHtcclxuICAgICAgICBjb25zdCBzdWNjZXNzID0gcGFyYW1zWzFdO1xyXG5cclxuICAgICAgICBjb25zdCBzaG93SGlkZU1vZGFsID0gKGNsYXNzTmFtZSwgdGV4dCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2RhbEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7ICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hlYWRlcicpO1xyXG4gICAgICAgICAgICBtb2RhbEVsLmNsYXNzTGlzdC5hZGQoJ21vZGFsJyk7XHJcbiAgICAgICAgICAgIG1vZGFsRWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICBtb2RhbEVsLnRleHRDb250ZW50ID0gdGV4dDtcclxuICAgICAgICAgICAgaGVhZGVyLmFwcGVuZChtb2RhbEVsKTtcclxuXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbW9kYWxFbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfSwgNTAwMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzd2l0Y2ggKHN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgY2FzZSAndHJ1ZSc6IHtcclxuICAgICAgICAgICAgICAgIHNob3dIaWRlTW9kYWwoJ3N1Y2Nlc3MnLCAnUG92ZWRsbyBzZSBwxZlpZGF0IFbDocWhIGUtbWFpbCEnKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgJ2ZhbHNlJzoge1xyXG4gICAgICAgICAgICAgICAgc2hvd0hpZGVNb2RhbCgnZmFpbCcsICdQxZlpZMOhbsOtIGUtbWFpbHUgc2UgbmVwb2RhxZlpbG8uJyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLy8vLyBBTklNQVRJT05TXHJcbi8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLy9Db2xsZWN0aW5nIGFsbCBlbGVtZW50cyB3aXRoIGNsYXNzIFwidG9CZUFuaW1hdGVkXCJcclxuY29uc3QgdG9CZUFuaW1hdGVkRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudG9CZUFuaW1hdGVkJyk7XHJcblxyXG4vL0NyZWF0aW5nIGFycmF5IG9mIHBhaXJzIG9mIHRvIGJlIGFuaW1hdGVkIGVsZW1lbnRzIGFuZCB0aGVpciBkaXN0YW5jZSBmcm9tIGRvY3VtZW50IHRvcCBib3JkZXIgIC0+IFtbZWxlbWVudDEsIGRpc3RhbmNlMV0sIFtlbGVtZW50MiwgZGlzdGFuY2UyXSwgLi4uIF1cclxubGV0IHRvQmVBbmltYXRlZCA9IFtdO1xyXG5mb3IgKGNvbnN0IGVsZW1lbnQgb2YgdG9CZUFuaW1hdGVkRWxlbWVudHMpIHtcclxuICAgIHRvQmVBbmltYXRlZC5wdXNoKFtlbGVtZW50LCBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXSk7XHJcbn1cclxuXHJcbmNvbnN0IHRvQmVBbmltYXRlZFNuYXBzaG90ID0gdG9CZUFuaW1hdGVkO1xyXG5cclxuLy9IYW5kbGVyIGZvciAnc2Nyb2xsJyBldmVudCBvbiBkb2N1bWVudC53aW5kb3csIHRyaWdnZXJzIGFuaW1hdGlvbnNcclxuY29uc3QgYW5pbWF0aW9uVHJpZ2dlcmVyID0gKCkgPT4ge1xyXG5cclxuICAgIC8vQ29udGFpbnMgaWTCtHMgb2YgZWxlbWVudHMgKGluIHRvQmVBbmltYXRlZFtdKSwgdGhhdCBhcmUgZ29pbmcgdG8gYmUgYW5pbWF0ZWQgdGhpcyBmdW5jdGlvbiBjYWxsXHJcbiAgICBjb25zdCB3aWxsQmVBbmltYXRlZCA9IFtdO1xyXG5cclxuICAgIGZvciAoY29uc3QgYW5pbWF0aW9uIG9mIHRvQmVBbmltYXRlZCkge1xyXG5cclxuICAgICAgICBpZiAoYW5pbWF0aW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL0lmIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHdpbmRvdyB0b3AgYW5kIGVsZW1lbnTCtHMgeSBjb29yZGluYXRlIGlzIHNtYWxsIGVub3VnaCwgYW5pbWF0aW5nIHRoZSBlbGVtZW50XHJcbiAgICAgICAgaWYgKGFuaW1hdGlvblsxXSAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgPD0gd2luZG93LmlubmVySGVpZ2h0IC0gMTAwKSB7XHJcblxyXG4gICAgICAgICAgICAvL1JlbW92aW5nIHRvQmVBbmltYXRlZCBjbGFzc1xyXG4gICAgICAgICAgICBhbmltYXRpb25bMF0uY2xhc3NMaXN0LnJlbW92ZSgndG9CZUFuaW1hdGVkJyk7XHJcblxyXG4gICAgICAgICAgICAvL0ZpbmRpbmcgaW5kZXggb2YgdGhlIGVsZW1lbnRcclxuICAgICAgICAgICAgY29uc3QgaWQgPSB0b0JlQW5pbWF0ZWQuZmluZEluZGV4KChhbmltKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uID09PSBhbmltO1xyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy9BZGRpbmcgaW5kZXggdG8gdGhlIGxpc3RcclxuICAgICAgICAgICAgd2lsbEJlQW5pbWF0ZWQucHVzaChpZCk7XHJcbiAgICAgICAgfSAgXHJcbiAgICB9XHJcblxyXG4gICAgLy9JZiB0aGVyZSBhcmUgc29tZSBlbGVtZW50cyB0aGF0IGFyZSBnb2luZyB0byBiZSBhbmltYXRlZCB0aGlzIGZ1bmN0aW9uIGNhbGxcclxuICAgIGlmICh3aWxsQmVBbmltYXRlZC5sZW5ndGggPiAwKSB7XHJcblxyXG4gICAgICAgIC8vTWFwcGluZyB0b0JlQW5pbWF0ZWQgYXJyYXkgdG8gYW4gYXJyYXksIGluIHdoaWNoIHRoZSBlbGVtZW50cyBhbmltYXRlZCB0aGlzIGZ1bmN0aW9uIGNhbGwgYXJlIG5vdCBpbmNsdWRlZFxyXG4gICAgICAgIHRvQmVBbmltYXRlZCA9IHRvQmVBbmltYXRlZC5tYXAoKHZhbHVlLCBpZHgpID0+IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBpZCBvZiB3aWxsQmVBbmltYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlkID09PSBpZHgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbn1cclxuXHJcbi8vV2hlbiB1c2VyIHNjcm9sbHMsIHRyaWdnZXJpbmcgYW5pbWF0aW9uc1xyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKCkgPT4ge1xyXG4gICAgYW5pbWF0aW9uVHJpZ2dlcmVyKCk7XHJcbn0pXHJcblxyXG4vL1ByZXZlbnRpbmcgbWlzYmVoYXZpb3Igb24gd2luZG93IHJlc2l6ZVxyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCkgPT4ge1xyXG4gICAgdG9CZUFuaW1hdGVkID0gdG9CZUFuaW1hdGVkU25hcHNob3Q7XHJcbn0pXHJcblxyXG4vL1RyaWdnZXJpbmcgYW5pbWF0aW9ucyBvbiBwYWdlIGxvYWRcclxuYW5pbWF0aW9uVHJpZ2dlcmVyKCk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/client/js/index.js\n");
/******/ })()
;