/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/*!********************************!*\
  !*** ./src/client/js/index.js ***!
  \********************************/
eval("// UTILITY FUNCTIONS\r\n\r\n// Rendering the element or removing it from the screen smoothly - with animations\r\n// The element must have 3 CSS Classes available - hidden class, visible class, hiding class\r\n// Hidden class - display: none, no animation\r\n// Visible class - display: block (or whatever except none) and an animation of the element appearing on the page (sliding -in or so)\r\n// Hiding class - animation of the element disappearing\r\n// Element has only one of these classes at a time.\r\nconst showOrHideEl = (element, cssClass) => {\r\n  if ([...element.classList].includes(`${cssClass}--hidden`)) {\r\n    element.classList.remove(`${cssClass}--hidden`);\r\n    element.classList.add(`${cssClass}--visible`);\r\n  } else if ([...element.classList].includes(`${cssClass}--visible`)) {\r\n    element.classList.remove(`${cssClass}--visible`);\r\n    element.classList.add(`${cssClass}--hiding`);\r\n  } else {\r\n    element.classList.remove(`${cssClass}--hiding`);\r\n    element.classList.add(`${cssClass}--hidden`);\r\n  }\r\n};\r\n\r\n// ORGANIZATIONS\r\n\r\nconst organizationContainer = document.querySelector(\r\n  \".organizations__container\"\r\n);\r\nconst organizationElements = [...organizationContainer.children];\r\n\r\n//When mouse cursor enters organization div, rendering animation\r\norganizationElements.forEach((organization, id) => {\r\n  organization.addEventListener(\"mouseenter\", () => {\r\n    createWaveAnimation(id);\r\n  });\r\n});\r\n\r\n// Creating hidden style element for @keyframes\r\nconst animations = document.createElement(\"style\");\r\ndocument.documentElement.appendChild(animations);\r\n\r\n// The wave svg isn´t by default pointing to 0 rad, so I experimentally found out the angle correction\r\nconst angleCorrection = -1; //[rad]\r\n\r\n// Counting each wave animation creating. This count is used for creating unique animation id´s\r\nlet animationCounter = 0;\r\n\r\n// Managing all currently needed @keyframes in an array\r\nlet keyframesList = [];\r\n\r\n// Setting max amount and min amount of waves that can appear\r\nconst maxWaves = 5;\r\nconst minWaves = 2;\r\n\r\n//Setting initial wave range\r\nlet waveRange = 10; //[rem]\r\n\r\n// This function sets the wave range taking the window size in account\r\nconst setUpWaveRange = () => {\r\n  if (\r\n    document.documentElement.clientWidth < 1100 &&\r\n    document.documentElement.clientWidth >= 800\r\n  ) {\r\n    waveRange = 7;\r\n  } else if (document.documentElement.clientWidth < 800) {\r\n    waveRange = 6;\r\n  } else {\r\n    waveRange = 10;\r\n  }\r\n};\r\n\r\n// Whenever window is resized, configuring the wave range, so the wave range is \"responsive\"\r\nwindow.addEventListener(\"resize\", () => {\r\n  setUpWaveRange();\r\n});\r\n\r\n// Function animates wave element in specified organization element\r\nconst animateWave = (wave, organizationIndex) => {\r\n  //Generating random angle to get direction, in which the wave will move\r\n  const randomAngle = Math.random() * 2 * Math.PI;\r\n\r\n  //Generating X and Y offset from the original position based on the random angle\r\n  const moveX = Math.cos(randomAngle) * waveRange;\r\n  const moveY = Math.sin(randomAngle) * waveRange;\r\n\r\n  //Animation id refers to the total amount of animations created, therefore is unique\r\n  const animationId = animationCounter;\r\n\r\n  //Generating @keyframes identifier - animation name\r\n  const animationName = `waveAnimation--${organizationIndex}--${animationId}`;\r\n  animationCounter++;\r\n\r\n  //Generating keyframes\r\n  const keyframes = `@keyframes ${animationName} {\r\n        0% {\r\n            transform: scale(0.1) translateX(0) translateY(0) rotate(${\r\n              randomAngle + angleCorrection\r\n            }rad);\r\n            opacity: 0;\r\n            filter: blur(0px);\r\n        }\r\n        50% {\r\n            opacity: .3;\r\n        }\r\n        100% {\r\n            transform: scale(2) translateX(${moveX}rem) translateY(${moveY}rem) rotate(${\r\n    randomAngle + angleCorrection\r\n  }rad);\r\n            opacity : 0;\r\n            filter: blur(2px);\r\n            \r\n        }\r\n    }`;\r\n\r\n  // Adding keyframes to keyframeslist. (Manages all active animations)\r\n  keyframesList.push({ id: animationId, keyframes: keyframes });\r\n\r\n  // Replacing the <style> element´s content with a new text content, that contains all the keyframes from animationList\r\n  animations.textContent = keyframesList\r\n    .map((item) => item.keyframes)\r\n    .join(\" \");\r\n\r\n  // Applying animation to the wave element\r\n  wave.style.animation = `${animationName} 3s forwards`;\r\n\r\n  // Handling situation, hen wave element animation finishes\r\n  wave.addEventListener(\"animationend\", () => {\r\n    // Removing animation keyframes from the keyframesList\r\n    keyframesList.splice(\r\n      keyframesList.findIndex((item) => {\r\n        return animationId === item.id;\r\n      }),\r\n      1\r\n    );\r\n\r\n    //Updatng <style> element\r\n    animations.textContent = keyframesList\r\n      .map((item) => item.keyframes)\r\n      .join(\" \");\r\n\r\n    // Remowing wave element from DOM\r\n    wave.parentElement.removeChild(wave);\r\n  });\r\n};\r\n\r\n//Creates a new wave element\r\nconst spawnWave = (id) => {\r\n  const wave = document.createElement(\"div\");\r\n  wave.classList = `organizations__wave organizationions__wave--${id}`;\r\n\r\n  return wave;\r\n};\r\n\r\n//Generates wave animation for specified organization\r\nconst createWaveAnimation = (organizationIndex) => {\r\n  //Hooking organization element\r\n  const organization = organizationElements[organizationIndex];\r\n\r\n  //Selecting number of animations, that will appear during the animation (number is whole and falls between maxWaves and minWaves)\r\n  const waveNum = Math.floor(Math.random() * (maxWaves - minWaves) + minWaves);\r\n\r\n  //Creating selected number of waves, animating them\r\n  for (let i = 0; i < waveNum; i++) {\r\n    const wave = spawnWave(i);\r\n    organization.appendChild(wave);\r\n    animateWave(wave, organizationIndex);\r\n  }\r\n};\r\n\r\n//Setting up wave range initially\r\nsetUpWaveRange();\r\n\r\n//REVIEWS\r\n\r\n//Cyclically changes the state of review elements (HIDDEN -> VISIBLE -> HIDING -> HIDDEN -> ...)\r\nconst showOrHideReviewElements = (reviewLeaf, reviewPerson, reviewText) => {\r\n  showOrHideEl(reviewLeaf, \"review__leaf\");\r\n  showOrHideEl(reviewPerson, \"review__person\");\r\n  showOrHideEl(reviewText, \"review__text\");\r\n};\r\n\r\n//Hooking reviews section\r\nconst reviewsSection = document.getElementById(\"reviews\");\r\n\r\n//Getting array of reviews\r\nconst reviews = reviewsSection.children;\r\n\r\n//Setting up iterator\r\nlet currentId = 0;\r\n\r\n//When called, starts cycling through reviews (browser calls it again, when leaf animation ends)\r\nconst reviewCycler = () => {\r\n  //Getting current review\r\n  const review = reviews[currentId];\r\n\r\n  //Adding active class, so the reviw doesn´t have display: none anymore\r\n  review.classList.add(\"review--active\");\r\n\r\n  //Getting reviewLeaf, reviewText and reviewPerson\r\n  const reviewLeaf = review.querySelector(\".review__leaf\");\r\n  const reviewText = review.querySelector(\".review__text\");\r\n  const reviewPerson = review.querySelector(\".review__person\");\r\n\r\n  //Setting state for review elements from HIDDEN to VISIBLE\r\n  showOrHideReviewElements(reviewLeaf, reviewPerson, reviewText);\r\n\r\n  //Incrementing the iterator\r\n  currentId++;\r\n\r\n  //If the iterator after incrementing exceeds review count, setting it back to 0, so the cycling can continue from the first review\r\n  if (currentId === reviews.length) {\r\n    currentId = 0;\r\n  }\r\n\r\n  //Setting timeout for when should the review start disappearing\r\n  setTimeout(() => {\r\n    //Setting state for review elements from VISIBLE to HIDING\r\n    showOrHideReviewElements(reviewLeaf, reviewPerson, reviewText);\r\n\r\n    //When leaf fall animation finishes\r\n    reviewLeaf.addEventListener(\r\n      \"animationend\",\r\n      () => {\r\n        //Setting state for review elements from HIDING to HIDDEN\r\n        showOrHideReviewElements(reviewLeaf, reviewPerson, reviewText);\r\n\r\n        //Removing the review active class, therefore display: none is set\r\n        review.classList.remove(\"review--active\");\r\n\r\n        //Beginning antother cycle\r\n        reviewCycler();\r\n      },\r\n      // Making sure, that the leaf fall animation event triggers only once\r\n      {\r\n        capture: false,\r\n        once: true,\r\n        passive: false,\r\n      }\r\n    );\r\n  }, 7000);\r\n};\r\n\r\n//Starting to cycle when the page loads\r\nreviewCycler();\r\n\r\n//////////////////\r\n///// POST EMAIL FORM\r\n//////////////////\r\nconst emailInput = document.getElementById(\"email\");\r\nemailInput.addEventListener(\"input\", () => {\r\n  const submit = document.getElementById(\"submit\");\r\n  submit.classList.remove(\"hidden\");\r\n  setTimeout(() => {\r\n    submit.style.opacity = \"1\";\r\n  }, 20);\r\n});\r\n\r\n//////////////////\r\n///// POST-SCRIPTUM EXPANSION\r\n//////////////////\r\nconst postScriptum = document.getElementById(\"post-scriptum\");\r\nconst showPSPhoto = () => {\r\n  postScriptum.classList.remove(\"closed\");\r\n  postScriptum.removeEventListener(\"click\", showPSPhoto);\r\n};\r\npostScriptum.addEventListener(\"click\", showPSPhoto);\r\n\r\n//////////////////\r\n///// SUCCESS MODAL\r\n//////////////////\r\nconst search = window.location.search;\r\nif (search) {\r\n  const params = search.split(\"=\");\r\n  if ((params && params[0] === \"?success\") || params[0] === \"success\") {\r\n    const success = params[1];\r\n\r\n    const showHideModal = (className, text) => {\r\n      const modalEl = document.createElement(\"div\");\r\n      const header = document.getElementById(\"header\");\r\n      modalEl.classList.add(\"modal\");\r\n      modalEl.classList.add(className);\r\n      modalEl.textContent = text;\r\n      header.append(modalEl);\r\n\r\n      setTimeout(() => {\r\n        modalEl.remove();\r\n      }, 5000);\r\n    };\r\n\r\n    switch (success) {\r\n      case \"true\": {\r\n        showHideModal(\"success\", \"Povedlo se přidat Váš e-mail!\");\r\n        break;\r\n      }\r\n      case \"false\": {\r\n        showHideModal(\"fail\", \"Přidání e-mailu se nepodařilo.\");\r\n        break;\r\n      }\r\n      default:\r\n        null;\r\n    }\r\n  }\r\n}\r\n\r\n//////////////////\r\n///// ANIMATIONS\r\n//////////////////\r\n\r\n//Collecting all elements with class \"toBeAnimated\"\r\nconst toBeAnimatedElements = document.querySelectorAll(\".toBeAnimated\");\r\n\r\n//Creating array of pairs of to be animated elements and their distance from document top border  -> [[element1, distance1], [element2, distance2], ... ]\r\nlet toBeAnimated = [];\r\nfor (const element of toBeAnimatedElements) {\r\n  toBeAnimated.push([\r\n    element,\r\n    element.getBoundingClientRect().y + document.documentElement.scrollTop,\r\n  ]);\r\n}\r\n\r\n//Handler for 'scroll' event on document.window, triggers animations\r\nconst animationTriggerer = () => {\r\n  //Contains id´s of elements (in toBeAnimated[]), that are going to be animated this function call\r\n  const willBeAnimated = [];\r\n\r\n  for (const animation of toBeAnimated) {\r\n    if (animation === undefined) {\r\n      continue;\r\n    }\r\n\r\n    //If the distance between window top and element´s y coordinate is small enough, animating the element\r\n    if (\r\n      animation[1] - document.documentElement.scrollTop <=\r\n      window.innerHeight - 100\r\n    ) {\r\n      //Removing toBeAnimated class\r\n      animation[0].classList.remove(\"toBeAnimated\");\r\n\r\n      //Finding index of the element\r\n      const id = toBeAnimated.findIndex((anim) => {\r\n        return animation === anim;\r\n      });\r\n\r\n      //Adding index to the list\r\n      willBeAnimated.push(id);\r\n    }\r\n  }\r\n\r\n  //If there are some elements that are going to be animated this function call\r\n  if (willBeAnimated.length > 0) {\r\n    //Mapping toBeAnimated array to an array, in which the elements animated this function call are not included\r\n    toBeAnimated = toBeAnimated.map((value, idx) => {\r\n      for (const id of willBeAnimated) {\r\n        if (id === idx) {\r\n          return;\r\n        }\r\n      }\r\n      return value;\r\n    });\r\n  }\r\n};\r\n\r\n//When user scrolls, triggering animations\r\nwindow.addEventListener(\"scroll\", () => {\r\n  animationTriggerer();\r\n});\r\n\r\n//Preventing misbehavior on window resize\r\nwindow.addEventListener(\"resize\", () => {\r\n  //Updating toBeAnimated, because after resizing can the top position be different\r\n  toBeAnimated = [];\r\n  for (const element of toBeAnimatedElements) {\r\n    toBeAnimated.push([\r\n      element,\r\n      element.getBoundingClientRect().y + document.documentElement.scrollTop,\r\n    ]);\r\n  }\r\n});\r\n\r\n//Triggering animations on page load\r\nanimationTriggerer();\r\n\r\n// Removing book img bug\r\nconst bookImg = document.querySelector(\".book__image\");\r\nif (bookImg) {\r\n  setTimeout(() => {\r\n    bookImg.style.minWidth = \"5rem\";\r\n  }, 500);\r\n}\r\n\r\nconst courseButton = document.getElementById(\"course__button\");\r\nconst courseSection = document.getElementById(\"course__section\");\r\n\r\nconst courseHTML = `\r\n    <svg\r\n    class=\"course__bloom1\"\r\n    width=\"59\"\r\n    height=\"65\"\r\n    viewBox=\"0 0 59 65\"\r\n    fill=\"none\"\r\n    xmlns=\"http://www.w3.org/2000/svg\"\r\n    >\r\n    <use xlink:href=\"#bloom\"></use>\r\n    </svg>\r\n\r\n    <svg\r\n    class=\"course__bloom2\"\r\n    width=\"59\"\r\n    height=\"65\"\r\n    viewBox=\"0 0 59 65\"\r\n    fill=\"none\"\r\n    xmlns=\"http://www.w3.org/2000/svg\"\r\n    >\r\n    <use xlink:href=\"#bloom\"></use>\r\n    </svg>\r\n\r\n    <svg\r\n    class=\"course__bloom3\"\r\n    width=\"59\"\r\n    height=\"65\"\r\n    viewBox=\"0 0 59 65\"\r\n    fill=\"none\"\r\n    xmlns=\"http://www.w3.org/2000/svg\"\r\n    >\r\n    <use xlink:href=\"#bloom\"></use>\r\n    </svg>\r\n\r\n    <p class=\"course__text__contact\">\r\n        Kontaktujte nás prosím na mailu barbara.dobesova@seznam.cz\r\n    </p>\r\n\r\n    <div class=\"course__phone\">\r\n        <p class=\"course__phone__text\">Tel. číslo :</p>\r\n        <p class=\"course__phone__text\">732 588 884</p>\r\n    </div>\r\n\r\n    <a\r\n        href=\"https://www.facebook.com/tatjana.horka.9\"        \r\n        class=\"course__button course__button__padding--contact\"\r\n        target=\"_blank\"\r\n    >\r\n        Facebook: Tatjana Horká\r\n    </a>\r\n\r\n    <a     \r\n        href=\"https://www.facebook.com/barbara.dobesova\"       \r\n        class=\"course__button course__button__padding--contact\"\r\n        target=\"_blank\"\r\n    >\r\n        Facebook: Barbara Dobešová\r\n    </a>\r\n`;\r\n\r\nconst handleCourseButton = () => {\r\n  courseSection.innerHTML = courseHTML;\r\n};\r\n\r\ncourseButton.addEventListener(\"mousedown\", handleCourseButton);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2xpZW50L2pzL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGF0amFuYWhvcmthLy4vc3JjL2NsaWVudC9qcy9pbmRleC5qcz8yYTUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFVUSUxJVFkgRlVOQ1RJT05TXHJcblxyXG4vLyBSZW5kZXJpbmcgdGhlIGVsZW1lbnQgb3IgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgc2NyZWVuIHNtb290aGx5IC0gd2l0aCBhbmltYXRpb25zXHJcbi8vIFRoZSBlbGVtZW50IG11c3QgaGF2ZSAzIENTUyBDbGFzc2VzIGF2YWlsYWJsZSAtIGhpZGRlbiBjbGFzcywgdmlzaWJsZSBjbGFzcywgaGlkaW5nIGNsYXNzXHJcbi8vIEhpZGRlbiBjbGFzcyAtIGRpc3BsYXk6IG5vbmUsIG5vIGFuaW1hdGlvblxyXG4vLyBWaXNpYmxlIGNsYXNzIC0gZGlzcGxheTogYmxvY2sgKG9yIHdoYXRldmVyIGV4Y2VwdCBub25lKSBhbmQgYW4gYW5pbWF0aW9uIG9mIHRoZSBlbGVtZW50IGFwcGVhcmluZyBvbiB0aGUgcGFnZSAoc2xpZGluZyAtaW4gb3Igc28pXHJcbi8vIEhpZGluZyBjbGFzcyAtIGFuaW1hdGlvbiBvZiB0aGUgZWxlbWVudCBkaXNhcHBlYXJpbmdcclxuLy8gRWxlbWVudCBoYXMgb25seSBvbmUgb2YgdGhlc2UgY2xhc3NlcyBhdCBhIHRpbWUuXHJcbmNvbnN0IHNob3dPckhpZGVFbCA9IChlbGVtZW50LCBjc3NDbGFzcykgPT4ge1xyXG4gIGlmIChbLi4uZWxlbWVudC5jbGFzc0xpc3RdLmluY2x1ZGVzKGAke2Nzc0NsYXNzfS0taGlkZGVuYCkpIHtcclxuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShgJHtjc3NDbGFzc30tLWhpZGRlbmApO1xyXG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGAke2Nzc0NsYXNzfS0tdmlzaWJsZWApO1xyXG4gIH0gZWxzZSBpZiAoWy4uLmVsZW1lbnQuY2xhc3NMaXN0XS5pbmNsdWRlcyhgJHtjc3NDbGFzc30tLXZpc2libGVgKSkge1xyXG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGAke2Nzc0NsYXNzfS0tdmlzaWJsZWApO1xyXG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGAke2Nzc0NsYXNzfS0taGlkaW5nYCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShgJHtjc3NDbGFzc30tLWhpZGluZ2ApO1xyXG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGAke2Nzc0NsYXNzfS0taGlkZGVuYCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gT1JHQU5JWkFUSU9OU1xyXG5cclxuY29uc3Qgb3JnYW5pemF0aW9uQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcclxuICBcIi5vcmdhbml6YXRpb25zX19jb250YWluZXJcIlxyXG4pO1xyXG5jb25zdCBvcmdhbml6YXRpb25FbGVtZW50cyA9IFsuLi5vcmdhbml6YXRpb25Db250YWluZXIuY2hpbGRyZW5dO1xyXG5cclxuLy9XaGVuIG1vdXNlIGN1cnNvciBlbnRlcnMgb3JnYW5pemF0aW9uIGRpdiwgcmVuZGVyaW5nIGFuaW1hdGlvblxyXG5vcmdhbml6YXRpb25FbGVtZW50cy5mb3JFYWNoKChvcmdhbml6YXRpb24sIGlkKSA9PiB7XHJcbiAgb3JnYW5pemF0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsICgpID0+IHtcclxuICAgIGNyZWF0ZVdhdmVBbmltYXRpb24oaWQpO1xyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8vIENyZWF0aW5nIGhpZGRlbiBzdHlsZSBlbGVtZW50IGZvciBAa2V5ZnJhbWVzXHJcbmNvbnN0IGFuaW1hdGlvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcbmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChhbmltYXRpb25zKTtcclxuXHJcbi8vIFRoZSB3YXZlIHN2ZyBpc27CtHQgYnkgZGVmYXVsdCBwb2ludGluZyB0byAwIHJhZCwgc28gSSBleHBlcmltZW50YWxseSBmb3VuZCBvdXQgdGhlIGFuZ2xlIGNvcnJlY3Rpb25cclxuY29uc3QgYW5nbGVDb3JyZWN0aW9uID0gLTE7IC8vW3JhZF1cclxuXHJcbi8vIENvdW50aW5nIGVhY2ggd2F2ZSBhbmltYXRpb24gY3JlYXRpbmcuIFRoaXMgY291bnQgaXMgdXNlZCBmb3IgY3JlYXRpbmcgdW5pcXVlIGFuaW1hdGlvbiBpZMK0c1xyXG5sZXQgYW5pbWF0aW9uQ291bnRlciA9IDA7XHJcblxyXG4vLyBNYW5hZ2luZyBhbGwgY3VycmVudGx5IG5lZWRlZCBAa2V5ZnJhbWVzIGluIGFuIGFycmF5XHJcbmxldCBrZXlmcmFtZXNMaXN0ID0gW107XHJcblxyXG4vLyBTZXR0aW5nIG1heCBhbW91bnQgYW5kIG1pbiBhbW91bnQgb2Ygd2F2ZXMgdGhhdCBjYW4gYXBwZWFyXHJcbmNvbnN0IG1heFdhdmVzID0gNTtcclxuY29uc3QgbWluV2F2ZXMgPSAyO1xyXG5cclxuLy9TZXR0aW5nIGluaXRpYWwgd2F2ZSByYW5nZVxyXG5sZXQgd2F2ZVJhbmdlID0gMTA7IC8vW3JlbV1cclxuXHJcbi8vIFRoaXMgZnVuY3Rpb24gc2V0cyB0aGUgd2F2ZSByYW5nZSB0YWtpbmcgdGhlIHdpbmRvdyBzaXplIGluIGFjY291bnRcclxuY29uc3Qgc2V0VXBXYXZlUmFuZ2UgPSAoKSA9PiB7XHJcbiAgaWYgKFxyXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIDwgMTEwMCAmJlxyXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoID49IDgwMFxyXG4gICkge1xyXG4gICAgd2F2ZVJhbmdlID0gNztcclxuICB9IGVsc2UgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCA8IDgwMCkge1xyXG4gICAgd2F2ZVJhbmdlID0gNjtcclxuICB9IGVsc2Uge1xyXG4gICAgd2F2ZVJhbmdlID0gMTA7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gV2hlbmV2ZXIgd2luZG93IGlzIHJlc2l6ZWQsIGNvbmZpZ3VyaW5nIHRoZSB3YXZlIHJhbmdlLCBzbyB0aGUgd2F2ZSByYW5nZSBpcyBcInJlc3BvbnNpdmVcIlxyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCAoKSA9PiB7XHJcbiAgc2V0VXBXYXZlUmFuZ2UoKTtcclxufSk7XHJcblxyXG4vLyBGdW5jdGlvbiBhbmltYXRlcyB3YXZlIGVsZW1lbnQgaW4gc3BlY2lmaWVkIG9yZ2FuaXphdGlvbiBlbGVtZW50XHJcbmNvbnN0IGFuaW1hdGVXYXZlID0gKHdhdmUsIG9yZ2FuaXphdGlvbkluZGV4KSA9PiB7XHJcbiAgLy9HZW5lcmF0aW5nIHJhbmRvbSBhbmdsZSB0byBnZXQgZGlyZWN0aW9uLCBpbiB3aGljaCB0aGUgd2F2ZSB3aWxsIG1vdmVcclxuICBjb25zdCByYW5kb21BbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcclxuXHJcbiAgLy9HZW5lcmF0aW5nIFggYW5kIFkgb2Zmc2V0IGZyb20gdGhlIG9yaWdpbmFsIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSByYW5kb20gYW5nbGVcclxuICBjb25zdCBtb3ZlWCA9IE1hdGguY29zKHJhbmRvbUFuZ2xlKSAqIHdhdmVSYW5nZTtcclxuICBjb25zdCBtb3ZlWSA9IE1hdGguc2luKHJhbmRvbUFuZ2xlKSAqIHdhdmVSYW5nZTtcclxuXHJcbiAgLy9BbmltYXRpb24gaWQgcmVmZXJzIHRvIHRoZSB0b3RhbCBhbW91bnQgb2YgYW5pbWF0aW9ucyBjcmVhdGVkLCB0aGVyZWZvcmUgaXMgdW5pcXVlXHJcbiAgY29uc3QgYW5pbWF0aW9uSWQgPSBhbmltYXRpb25Db3VudGVyO1xyXG5cclxuICAvL0dlbmVyYXRpbmcgQGtleWZyYW1lcyBpZGVudGlmaWVyIC0gYW5pbWF0aW9uIG5hbWVcclxuICBjb25zdCBhbmltYXRpb25OYW1lID0gYHdhdmVBbmltYXRpb24tLSR7b3JnYW5pemF0aW9uSW5kZXh9LS0ke2FuaW1hdGlvbklkfWA7XHJcbiAgYW5pbWF0aW9uQ291bnRlcisrO1xyXG5cclxuICAvL0dlbmVyYXRpbmcga2V5ZnJhbWVzXHJcbiAgY29uc3Qga2V5ZnJhbWVzID0gYEBrZXlmcmFtZXMgJHthbmltYXRpb25OYW1lfSB7XHJcbiAgICAgICAgMCUge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuMSkgdHJhbnNsYXRlWCgwKSB0cmFuc2xhdGVZKDApIHJvdGF0ZSgke1xyXG4gICAgICAgICAgICAgIHJhbmRvbUFuZ2xlICsgYW5nbGVDb3JyZWN0aW9uXHJcbiAgICAgICAgICAgIH1yYWQpO1xyXG4gICAgICAgICAgICBvcGFjaXR5OiAwO1xyXG4gICAgICAgICAgICBmaWx0ZXI6IGJsdXIoMHB4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgNTAlIHtcclxuICAgICAgICAgICAgb3BhY2l0eTogLjM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDEwMCUge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDIpIHRyYW5zbGF0ZVgoJHttb3ZlWH1yZW0pIHRyYW5zbGF0ZVkoJHttb3ZlWX1yZW0pIHJvdGF0ZSgke1xyXG4gICAgcmFuZG9tQW5nbGUgKyBhbmdsZUNvcnJlY3Rpb25cclxuICB9cmFkKTtcclxuICAgICAgICAgICAgb3BhY2l0eSA6IDA7XHJcbiAgICAgICAgICAgIGZpbHRlcjogYmx1cigycHgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICB9YDtcclxuXHJcbiAgLy8gQWRkaW5nIGtleWZyYW1lcyB0byBrZXlmcmFtZXNsaXN0LiAoTWFuYWdlcyBhbGwgYWN0aXZlIGFuaW1hdGlvbnMpXHJcbiAga2V5ZnJhbWVzTGlzdC5wdXNoKHsgaWQ6IGFuaW1hdGlvbklkLCBrZXlmcmFtZXM6IGtleWZyYW1lcyB9KTtcclxuXHJcbiAgLy8gUmVwbGFjaW5nIHRoZSA8c3R5bGU+IGVsZW1lbnTCtHMgY29udGVudCB3aXRoIGEgbmV3IHRleHQgY29udGVudCwgdGhhdCBjb250YWlucyBhbGwgdGhlIGtleWZyYW1lcyBmcm9tIGFuaW1hdGlvbkxpc3RcclxuICBhbmltYXRpb25zLnRleHRDb250ZW50ID0ga2V5ZnJhbWVzTGlzdFxyXG4gICAgLm1hcCgoaXRlbSkgPT4gaXRlbS5rZXlmcmFtZXMpXHJcbiAgICAuam9pbihcIiBcIik7XHJcblxyXG4gIC8vIEFwcGx5aW5nIGFuaW1hdGlvbiB0byB0aGUgd2F2ZSBlbGVtZW50XHJcbiAgd2F2ZS5zdHlsZS5hbmltYXRpb24gPSBgJHthbmltYXRpb25OYW1lfSAzcyBmb3J3YXJkc2A7XHJcblxyXG4gIC8vIEhhbmRsaW5nIHNpdHVhdGlvbiwgaGVuIHdhdmUgZWxlbWVudCBhbmltYXRpb24gZmluaXNoZXNcclxuICB3YXZlLmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgKCkgPT4ge1xyXG4gICAgLy8gUmVtb3ZpbmcgYW5pbWF0aW9uIGtleWZyYW1lcyBmcm9tIHRoZSBrZXlmcmFtZXNMaXN0XHJcbiAgICBrZXlmcmFtZXNMaXN0LnNwbGljZShcclxuICAgICAga2V5ZnJhbWVzTGlzdC5maW5kSW5kZXgoKGl0ZW0pID0+IHtcclxuICAgICAgICByZXR1cm4gYW5pbWF0aW9uSWQgPT09IGl0ZW0uaWQ7XHJcbiAgICAgIH0pLFxyXG4gICAgICAxXHJcbiAgICApO1xyXG5cclxuICAgIC8vVXBkYXRuZyA8c3R5bGU+IGVsZW1lbnRcclxuICAgIGFuaW1hdGlvbnMudGV4dENvbnRlbnQgPSBrZXlmcmFtZXNMaXN0XHJcbiAgICAgIC5tYXAoKGl0ZW0pID0+IGl0ZW0ua2V5ZnJhbWVzKVxyXG4gICAgICAuam9pbihcIiBcIik7XHJcblxyXG4gICAgLy8gUmVtb3dpbmcgd2F2ZSBlbGVtZW50IGZyb20gRE9NXHJcbiAgICB3YXZlLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQod2F2ZSk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG4vL0NyZWF0ZXMgYSBuZXcgd2F2ZSBlbGVtZW50XHJcbmNvbnN0IHNwYXduV2F2ZSA9IChpZCkgPT4ge1xyXG4gIGNvbnN0IHdhdmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gIHdhdmUuY2xhc3NMaXN0ID0gYG9yZ2FuaXphdGlvbnNfX3dhdmUgb3JnYW5pemF0aW9uaW9uc19fd2F2ZS0tJHtpZH1gO1xyXG5cclxuICByZXR1cm4gd2F2ZTtcclxufTtcclxuXHJcbi8vR2VuZXJhdGVzIHdhdmUgYW5pbWF0aW9uIGZvciBzcGVjaWZpZWQgb3JnYW5pemF0aW9uXHJcbmNvbnN0IGNyZWF0ZVdhdmVBbmltYXRpb24gPSAob3JnYW5pemF0aW9uSW5kZXgpID0+IHtcclxuICAvL0hvb2tpbmcgb3JnYW5pemF0aW9uIGVsZW1lbnRcclxuICBjb25zdCBvcmdhbml6YXRpb24gPSBvcmdhbml6YXRpb25FbGVtZW50c1tvcmdhbml6YXRpb25JbmRleF07XHJcblxyXG4gIC8vU2VsZWN0aW5nIG51bWJlciBvZiBhbmltYXRpb25zLCB0aGF0IHdpbGwgYXBwZWFyIGR1cmluZyB0aGUgYW5pbWF0aW9uIChudW1iZXIgaXMgd2hvbGUgYW5kIGZhbGxzIGJldHdlZW4gbWF4V2F2ZXMgYW5kIG1pbldhdmVzKVxyXG4gIGNvbnN0IHdhdmVOdW0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4V2F2ZXMgLSBtaW5XYXZlcykgKyBtaW5XYXZlcyk7XHJcblxyXG4gIC8vQ3JlYXRpbmcgc2VsZWN0ZWQgbnVtYmVyIG9mIHdhdmVzLCBhbmltYXRpbmcgdGhlbVxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd2F2ZU51bTsgaSsrKSB7XHJcbiAgICBjb25zdCB3YXZlID0gc3Bhd25XYXZlKGkpO1xyXG4gICAgb3JnYW5pemF0aW9uLmFwcGVuZENoaWxkKHdhdmUpO1xyXG4gICAgYW5pbWF0ZVdhdmUod2F2ZSwgb3JnYW5pemF0aW9uSW5kZXgpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vU2V0dGluZyB1cCB3YXZlIHJhbmdlIGluaXRpYWxseVxyXG5zZXRVcFdhdmVSYW5nZSgpO1xyXG5cclxuLy9SRVZJRVdTXHJcblxyXG4vL0N5Y2xpY2FsbHkgY2hhbmdlcyB0aGUgc3RhdGUgb2YgcmV2aWV3IGVsZW1lbnRzIChISURERU4gLT4gVklTSUJMRSAtPiBISURJTkcgLT4gSElEREVOIC0+IC4uLilcclxuY29uc3Qgc2hvd09ySGlkZVJldmlld0VsZW1lbnRzID0gKHJldmlld0xlYWYsIHJldmlld1BlcnNvbiwgcmV2aWV3VGV4dCkgPT4ge1xyXG4gIHNob3dPckhpZGVFbChyZXZpZXdMZWFmLCBcInJldmlld19fbGVhZlwiKTtcclxuICBzaG93T3JIaWRlRWwocmV2aWV3UGVyc29uLCBcInJldmlld19fcGVyc29uXCIpO1xyXG4gIHNob3dPckhpZGVFbChyZXZpZXdUZXh0LCBcInJldmlld19fdGV4dFwiKTtcclxufTtcclxuXHJcbi8vSG9va2luZyByZXZpZXdzIHNlY3Rpb25cclxuY29uc3QgcmV2aWV3c1NlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJldmlld3NcIik7XHJcblxyXG4vL0dldHRpbmcgYXJyYXkgb2YgcmV2aWV3c1xyXG5jb25zdCByZXZpZXdzID0gcmV2aWV3c1NlY3Rpb24uY2hpbGRyZW47XHJcblxyXG4vL1NldHRpbmcgdXAgaXRlcmF0b3JcclxubGV0IGN1cnJlbnRJZCA9IDA7XHJcblxyXG4vL1doZW4gY2FsbGVkLCBzdGFydHMgY3ljbGluZyB0aHJvdWdoIHJldmlld3MgKGJyb3dzZXIgY2FsbHMgaXQgYWdhaW4sIHdoZW4gbGVhZiBhbmltYXRpb24gZW5kcylcclxuY29uc3QgcmV2aWV3Q3ljbGVyID0gKCkgPT4ge1xyXG4gIC8vR2V0dGluZyBjdXJyZW50IHJldmlld1xyXG4gIGNvbnN0IHJldmlldyA9IHJldmlld3NbY3VycmVudElkXTtcclxuXHJcbiAgLy9BZGRpbmcgYWN0aXZlIGNsYXNzLCBzbyB0aGUgcmV2aXcgZG9lc27CtHQgaGF2ZSBkaXNwbGF5OiBub25lIGFueW1vcmVcclxuICByZXZpZXcuY2xhc3NMaXN0LmFkZChcInJldmlldy0tYWN0aXZlXCIpO1xyXG5cclxuICAvL0dldHRpbmcgcmV2aWV3TGVhZiwgcmV2aWV3VGV4dCBhbmQgcmV2aWV3UGVyc29uXHJcbiAgY29uc3QgcmV2aWV3TGVhZiA9IHJldmlldy5xdWVyeVNlbGVjdG9yKFwiLnJldmlld19fbGVhZlwiKTtcclxuICBjb25zdCByZXZpZXdUZXh0ID0gcmV2aWV3LnF1ZXJ5U2VsZWN0b3IoXCIucmV2aWV3X190ZXh0XCIpO1xyXG4gIGNvbnN0IHJldmlld1BlcnNvbiA9IHJldmlldy5xdWVyeVNlbGVjdG9yKFwiLnJldmlld19fcGVyc29uXCIpO1xyXG5cclxuICAvL1NldHRpbmcgc3RhdGUgZm9yIHJldmlldyBlbGVtZW50cyBmcm9tIEhJRERFTiB0byBWSVNJQkxFXHJcbiAgc2hvd09ySGlkZVJldmlld0VsZW1lbnRzKHJldmlld0xlYWYsIHJldmlld1BlcnNvbiwgcmV2aWV3VGV4dCk7XHJcblxyXG4gIC8vSW5jcmVtZW50aW5nIHRoZSBpdGVyYXRvclxyXG4gIGN1cnJlbnRJZCsrO1xyXG5cclxuICAvL0lmIHRoZSBpdGVyYXRvciBhZnRlciBpbmNyZW1lbnRpbmcgZXhjZWVkcyByZXZpZXcgY291bnQsIHNldHRpbmcgaXQgYmFjayB0byAwLCBzbyB0aGUgY3ljbGluZyBjYW4gY29udGludWUgZnJvbSB0aGUgZmlyc3QgcmV2aWV3XHJcbiAgaWYgKGN1cnJlbnRJZCA9PT0gcmV2aWV3cy5sZW5ndGgpIHtcclxuICAgIGN1cnJlbnRJZCA9IDA7XHJcbiAgfVxyXG5cclxuICAvL1NldHRpbmcgdGltZW91dCBmb3Igd2hlbiBzaG91bGQgdGhlIHJldmlldyBzdGFydCBkaXNhcHBlYXJpbmdcclxuICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgIC8vU2V0dGluZyBzdGF0ZSBmb3IgcmV2aWV3IGVsZW1lbnRzIGZyb20gVklTSUJMRSB0byBISURJTkdcclxuICAgIHNob3dPckhpZGVSZXZpZXdFbGVtZW50cyhyZXZpZXdMZWFmLCByZXZpZXdQZXJzb24sIHJldmlld1RleHQpO1xyXG5cclxuICAgIC8vV2hlbiBsZWFmIGZhbGwgYW5pbWF0aW9uIGZpbmlzaGVzXHJcbiAgICByZXZpZXdMZWFmLmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgIFwiYW5pbWF0aW9uZW5kXCIsXHJcbiAgICAgICgpID0+IHtcclxuICAgICAgICAvL1NldHRpbmcgc3RhdGUgZm9yIHJldmlldyBlbGVtZW50cyBmcm9tIEhJRElORyB0byBISURERU5cclxuICAgICAgICBzaG93T3JIaWRlUmV2aWV3RWxlbWVudHMocmV2aWV3TGVhZiwgcmV2aWV3UGVyc29uLCByZXZpZXdUZXh0KTtcclxuXHJcbiAgICAgICAgLy9SZW1vdmluZyB0aGUgcmV2aWV3IGFjdGl2ZSBjbGFzcywgdGhlcmVmb3JlIGRpc3BsYXk6IG5vbmUgaXMgc2V0XHJcbiAgICAgICAgcmV2aWV3LmNsYXNzTGlzdC5yZW1vdmUoXCJyZXZpZXctLWFjdGl2ZVwiKTtcclxuXHJcbiAgICAgICAgLy9CZWdpbm5pbmcgYW50b3RoZXIgY3ljbGVcclxuICAgICAgICByZXZpZXdDeWNsZXIoKTtcclxuICAgICAgfSxcclxuICAgICAgLy8gTWFraW5nIHN1cmUsIHRoYXQgdGhlIGxlYWYgZmFsbCBhbmltYXRpb24gZXZlbnQgdHJpZ2dlcnMgb25seSBvbmNlXHJcbiAgICAgIHtcclxuICAgICAgICBjYXB0dXJlOiBmYWxzZSxcclxuICAgICAgICBvbmNlOiB0cnVlLFxyXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxyXG4gICAgICB9XHJcbiAgICApO1xyXG4gIH0sIDcwMDApO1xyXG59O1xyXG5cclxuLy9TdGFydGluZyB0byBjeWNsZSB3aGVuIHRoZSBwYWdlIGxvYWRzXHJcbnJldmlld0N5Y2xlcigpO1xyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vLy8vIFBPU1QgRU1BSUwgRk9STVxyXG4vLy8vLy8vLy8vLy8vLy8vLy9cclxuY29uc3QgZW1haWxJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZW1haWxcIik7XHJcbmVtYWlsSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IHtcclxuICBjb25zdCBzdWJtaXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN1Ym1pdFwiKTtcclxuICBzdWJtaXQuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcclxuICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgIHN1Ym1pdC5zdHlsZS5vcGFjaXR5ID0gXCIxXCI7XHJcbiAgfSwgMjApO1xyXG59KTtcclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLy8vLyBQT1NULVNDUklQVFVNIEVYUEFOU0lPTlxyXG4vLy8vLy8vLy8vLy8vLy8vLy9cclxuY29uc3QgcG9zdFNjcmlwdHVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwb3N0LXNjcmlwdHVtXCIpO1xyXG5jb25zdCBzaG93UFNQaG90byA9ICgpID0+IHtcclxuICBwb3N0U2NyaXB0dW0uY2xhc3NMaXN0LnJlbW92ZShcImNsb3NlZFwiKTtcclxuICBwb3N0U2NyaXB0dW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHNob3dQU1Bob3RvKTtcclxufTtcclxucG9zdFNjcmlwdHVtLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBzaG93UFNQaG90byk7XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8vLy8gU1VDQ0VTUyBNT0RBTFxyXG4vLy8vLy8vLy8vLy8vLy8vLy9cclxuY29uc3Qgc2VhcmNoID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaDtcclxuaWYgKHNlYXJjaCkge1xyXG4gIGNvbnN0IHBhcmFtcyA9IHNlYXJjaC5zcGxpdChcIj1cIik7XHJcbiAgaWYgKChwYXJhbXMgJiYgcGFyYW1zWzBdID09PSBcIj9zdWNjZXNzXCIpIHx8IHBhcmFtc1swXSA9PT0gXCJzdWNjZXNzXCIpIHtcclxuICAgIGNvbnN0IHN1Y2Nlc3MgPSBwYXJhbXNbMV07XHJcblxyXG4gICAgY29uc3Qgc2hvd0hpZGVNb2RhbCA9IChjbGFzc05hbWUsIHRleHQpID0+IHtcclxuICAgICAgY29uc3QgbW9kYWxFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaGVhZGVyXCIpO1xyXG4gICAgICBtb2RhbEVsLmNsYXNzTGlzdC5hZGQoXCJtb2RhbFwiKTtcclxuICAgICAgbW9kYWxFbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XHJcbiAgICAgIG1vZGFsRWwudGV4dENvbnRlbnQgPSB0ZXh0O1xyXG4gICAgICBoZWFkZXIuYXBwZW5kKG1vZGFsRWwpO1xyXG5cclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgbW9kYWxFbC5yZW1vdmUoKTtcclxuICAgICAgfSwgNTAwMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHN3aXRjaCAoc3VjY2Vzcykge1xyXG4gICAgICBjYXNlIFwidHJ1ZVwiOiB7XHJcbiAgICAgICAgc2hvd0hpZGVNb2RhbChcInN1Y2Nlc3NcIiwgXCJQb3ZlZGxvIHNlIHDFmWlkYXQgVsOhxaEgZS1tYWlsIVwiKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlIFwiZmFsc2VcIjoge1xyXG4gICAgICAgIHNob3dIaWRlTW9kYWwoXCJmYWlsXCIsIFwiUMWZaWTDoW7DrSBlLW1haWx1IHNlIG5lcG9kYcWZaWxvLlwiKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8vLy8gQU5JTUFUSU9OU1xyXG4vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8vQ29sbGVjdGluZyBhbGwgZWxlbWVudHMgd2l0aCBjbGFzcyBcInRvQmVBbmltYXRlZFwiXHJcbmNvbnN0IHRvQmVBbmltYXRlZEVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50b0JlQW5pbWF0ZWRcIik7XHJcblxyXG4vL0NyZWF0aW5nIGFycmF5IG9mIHBhaXJzIG9mIHRvIGJlIGFuaW1hdGVkIGVsZW1lbnRzIGFuZCB0aGVpciBkaXN0YW5jZSBmcm9tIGRvY3VtZW50IHRvcCBib3JkZXIgIC0+IFtbZWxlbWVudDEsIGRpc3RhbmNlMV0sIFtlbGVtZW50MiwgZGlzdGFuY2UyXSwgLi4uIF1cclxubGV0IHRvQmVBbmltYXRlZCA9IFtdO1xyXG5mb3IgKGNvbnN0IGVsZW1lbnQgb2YgdG9CZUFuaW1hdGVkRWxlbWVudHMpIHtcclxuICB0b0JlQW5pbWF0ZWQucHVzaChbXHJcbiAgICBlbGVtZW50LFxyXG4gICAgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS55ICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCxcclxuICBdKTtcclxufVxyXG5cclxuLy9IYW5kbGVyIGZvciAnc2Nyb2xsJyBldmVudCBvbiBkb2N1bWVudC53aW5kb3csIHRyaWdnZXJzIGFuaW1hdGlvbnNcclxuY29uc3QgYW5pbWF0aW9uVHJpZ2dlcmVyID0gKCkgPT4ge1xyXG4gIC8vQ29udGFpbnMgaWTCtHMgb2YgZWxlbWVudHMgKGluIHRvQmVBbmltYXRlZFtdKSwgdGhhdCBhcmUgZ29pbmcgdG8gYmUgYW5pbWF0ZWQgdGhpcyBmdW5jdGlvbiBjYWxsXHJcbiAgY29uc3Qgd2lsbEJlQW5pbWF0ZWQgPSBbXTtcclxuXHJcbiAgZm9yIChjb25zdCBhbmltYXRpb24gb2YgdG9CZUFuaW1hdGVkKSB7XHJcbiAgICBpZiAoYW5pbWF0aW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy9JZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiB3aW5kb3cgdG9wIGFuZCBlbGVtZW50wrRzIHkgY29vcmRpbmF0ZSBpcyBzbWFsbCBlbm91Z2gsIGFuaW1hdGluZyB0aGUgZWxlbWVudFxyXG4gICAgaWYgKFxyXG4gICAgICBhbmltYXRpb25bMV0gLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIDw9XHJcbiAgICAgIHdpbmRvdy5pbm5lckhlaWdodCAtIDEwMFxyXG4gICAgKSB7XHJcbiAgICAgIC8vUmVtb3ZpbmcgdG9CZUFuaW1hdGVkIGNsYXNzXHJcbiAgICAgIGFuaW1hdGlvblswXS5jbGFzc0xpc3QucmVtb3ZlKFwidG9CZUFuaW1hdGVkXCIpO1xyXG5cclxuICAgICAgLy9GaW5kaW5nIGluZGV4IG9mIHRoZSBlbGVtZW50XHJcbiAgICAgIGNvbnN0IGlkID0gdG9CZUFuaW1hdGVkLmZpbmRJbmRleCgoYW5pbSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBhbmltYXRpb24gPT09IGFuaW07XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy9BZGRpbmcgaW5kZXggdG8gdGhlIGxpc3RcclxuICAgICAgd2lsbEJlQW5pbWF0ZWQucHVzaChpZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvL0lmIHRoZXJlIGFyZSBzb21lIGVsZW1lbnRzIHRoYXQgYXJlIGdvaW5nIHRvIGJlIGFuaW1hdGVkIHRoaXMgZnVuY3Rpb24gY2FsbFxyXG4gIGlmICh3aWxsQmVBbmltYXRlZC5sZW5ndGggPiAwKSB7XHJcbiAgICAvL01hcHBpbmcgdG9CZUFuaW1hdGVkIGFycmF5IHRvIGFuIGFycmF5LCBpbiB3aGljaCB0aGUgZWxlbWVudHMgYW5pbWF0ZWQgdGhpcyBmdW5jdGlvbiBjYWxsIGFyZSBub3QgaW5jbHVkZWRcclxuICAgIHRvQmVBbmltYXRlZCA9IHRvQmVBbmltYXRlZC5tYXAoKHZhbHVlLCBpZHgpID0+IHtcclxuICAgICAgZm9yIChjb25zdCBpZCBvZiB3aWxsQmVBbmltYXRlZCkge1xyXG4gICAgICAgIGlmIChpZCA9PT0gaWR4KSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH0pO1xyXG4gIH1cclxufTtcclxuXHJcbi8vV2hlbiB1c2VyIHNjcm9sbHMsIHRyaWdnZXJpbmcgYW5pbWF0aW9uc1xyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoKSA9PiB7XHJcbiAgYW5pbWF0aW9uVHJpZ2dlcmVyKCk7XHJcbn0pO1xyXG5cclxuLy9QcmV2ZW50aW5nIG1pc2JlaGF2aW9yIG9uIHdpbmRvdyByZXNpemVcclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgKCkgPT4ge1xyXG4gIC8vVXBkYXRpbmcgdG9CZUFuaW1hdGVkLCBiZWNhdXNlIGFmdGVyIHJlc2l6aW5nIGNhbiB0aGUgdG9wIHBvc2l0aW9uIGJlIGRpZmZlcmVudFxyXG4gIHRvQmVBbmltYXRlZCA9IFtdO1xyXG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiB0b0JlQW5pbWF0ZWRFbGVtZW50cykge1xyXG4gICAgdG9CZUFuaW1hdGVkLnB1c2goW1xyXG4gICAgICBlbGVtZW50LFxyXG4gICAgICBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wLFxyXG4gICAgXSk7XHJcbiAgfVxyXG59KTtcclxuXHJcbi8vVHJpZ2dlcmluZyBhbmltYXRpb25zIG9uIHBhZ2UgbG9hZFxyXG5hbmltYXRpb25UcmlnZ2VyZXIoKTtcclxuXHJcbi8vIFJlbW92aW5nIGJvb2sgaW1nIGJ1Z1xyXG5jb25zdCBib29rSW1nID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5ib29rX19pbWFnZVwiKTtcclxuaWYgKGJvb2tJbWcpIHtcclxuICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgIGJvb2tJbWcuc3R5bGUubWluV2lkdGggPSBcIjVyZW1cIjtcclxuICB9LCA1MDApO1xyXG59XHJcblxyXG5jb25zdCBjb3Vyc2VCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvdXJzZV9fYnV0dG9uXCIpO1xyXG5jb25zdCBjb3Vyc2VTZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb3Vyc2VfX3NlY3Rpb25cIik7XHJcblxyXG5jb25zdCBjb3Vyc2VIVE1MID0gYFxyXG4gICAgPHN2Z1xyXG4gICAgY2xhc3M9XCJjb3Vyc2VfX2Jsb29tMVwiXHJcbiAgICB3aWR0aD1cIjU5XCJcclxuICAgIGhlaWdodD1cIjY1XCJcclxuICAgIHZpZXdCb3g9XCIwIDAgNTkgNjVcIlxyXG4gICAgZmlsbD1cIm5vbmVcIlxyXG4gICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXHJcbiAgICA+XHJcbiAgICA8dXNlIHhsaW5rOmhyZWY9XCIjYmxvb21cIj48L3VzZT5cclxuICAgIDwvc3ZnPlxyXG5cclxuICAgIDxzdmdcclxuICAgIGNsYXNzPVwiY291cnNlX19ibG9vbTJcIlxyXG4gICAgd2lkdGg9XCI1OVwiXHJcbiAgICBoZWlnaHQ9XCI2NVwiXHJcbiAgICB2aWV3Qm94PVwiMCAwIDU5IDY1XCJcclxuICAgIGZpbGw9XCJub25lXCJcclxuICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxyXG4gICAgPlxyXG4gICAgPHVzZSB4bGluazpocmVmPVwiI2Jsb29tXCI+PC91c2U+XHJcbiAgICA8L3N2Zz5cclxuXHJcbiAgICA8c3ZnXHJcbiAgICBjbGFzcz1cImNvdXJzZV9fYmxvb20zXCJcclxuICAgIHdpZHRoPVwiNTlcIlxyXG4gICAgaGVpZ2h0PVwiNjVcIlxyXG4gICAgdmlld0JveD1cIjAgMCA1OSA2NVwiXHJcbiAgICBmaWxsPVwibm9uZVwiXHJcbiAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcclxuICAgID5cclxuICAgIDx1c2UgeGxpbms6aHJlZj1cIiNibG9vbVwiPjwvdXNlPlxyXG4gICAgPC9zdmc+XHJcblxyXG4gICAgPHAgY2xhc3M9XCJjb3Vyc2VfX3RleHRfX2NvbnRhY3RcIj5cclxuICAgICAgICBLb250YWt0dWp0ZSBuw6FzIHByb3PDrW0gbmEgbWFpbHUgYmFyYmFyYS5kb2Jlc292YUBzZXpuYW0uY3pcclxuICAgIDwvcD5cclxuXHJcbiAgICA8ZGl2IGNsYXNzPVwiY291cnNlX19waG9uZVwiPlxyXG4gICAgICAgIDxwIGNsYXNzPVwiY291cnNlX19waG9uZV9fdGV4dFwiPlRlbC4gxI3DrXNsbyA6PC9wPlxyXG4gICAgICAgIDxwIGNsYXNzPVwiY291cnNlX19waG9uZV9fdGV4dFwiPjczMiA1ODggODg0PC9wPlxyXG4gICAgPC9kaXY+XHJcblxyXG4gICAgPGFcclxuICAgICAgICBocmVmPVwiaHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3RhdGphbmEuaG9ya2EuOVwiICAgICAgICBcclxuICAgICAgICBjbGFzcz1cImNvdXJzZV9fYnV0dG9uIGNvdXJzZV9fYnV0dG9uX19wYWRkaW5nLS1jb250YWN0XCJcclxuICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxyXG4gICAgPlxyXG4gICAgICAgIEZhY2Vib29rOiBUYXRqYW5hIEhvcmvDoVxyXG4gICAgPC9hPlxyXG5cclxuICAgIDxhICAgICBcclxuICAgICAgICBocmVmPVwiaHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL2JhcmJhcmEuZG9iZXNvdmFcIiAgICAgICBcclxuICAgICAgICBjbGFzcz1cImNvdXJzZV9fYnV0dG9uIGNvdXJzZV9fYnV0dG9uX19wYWRkaW5nLS1jb250YWN0XCJcclxuICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxyXG4gICAgPlxyXG4gICAgICAgIEZhY2Vib29rOiBCYXJiYXJhIERvYmXFoW92w6FcclxuICAgIDwvYT5cclxuYDtcclxuXHJcbmNvbnN0IGhhbmRsZUNvdXJzZUJ1dHRvbiA9ICgpID0+IHtcclxuICBjb3Vyc2VTZWN0aW9uLmlubmVySFRNTCA9IGNvdXJzZUhUTUw7XHJcbn07XHJcblxyXG5jb3Vyc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBoYW5kbGVDb3Vyc2VCdXR0b24pO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/client/js/index.js\n");
/******/ })()
;